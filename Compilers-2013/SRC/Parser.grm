%{
(* SML header, after data types *)

  open AbSyn;
  
%}

%token <AbSyn.Pos> TProgram TEOF
%token <AbSyn.Pos> TFunction TProcedure TReturn
%token <string * AbSyn.Pos> TId
%token <AbSyn.Pos> TBegin TEnd
%token <AbSyn.Pos> TIf TThen TElse
%token <AbSyn.Pos> TWhile TDo
%token <AbSyn.Pos> TArray
%token <AbSyn.Pos> TOr TAnd TNot
%token <AbSyn.Pos> TVar TOf TChar TBool TInt 
%token <AbSyn.Pos> TSemi TColon TComma TAssign
%token <AbSyn.Pos> TPlus TMinus TTimes TSlash 
%token <AbSyn.Pos> TEq TLess
%token <AbSyn.Pos> TLParen TRParen TLCurly TRCurly TLBracket TRBracket
%token <int * AbSyn.Pos> TNLit
%token <bool * AbSyn.Pos> TBLit
%token <string * AbSyn.Pos> TSLit
%token <char * AbSyn.Pos> TCLit

%start Prog

%type <AbSyn.Return> Ret
%type <AbSyn.Type> Type
%type <AbSyn.Exp list> CallParams Exps
%type <AbSyn.Exp> Exp OP
%type <AbSyn.Dec> Dec
%type <AbSyn.LVal> LVal
%type <AbSyn.Stmt> Stmt
%type <AbSyn.Stmt list> SBlock StmtSeq
%type <AbSyn.Dec list> PDecl Params DBlock Decs
%type <AbSyn.StmtBlock> Block
%type <AbSyn.FunDec list> FunDecs
%type <AbSyn.FunDec> FunDec
%type <AbSyn.Prog> Prog

%nonassoc TNot
%left TOr TAnd
%left TEq TLess
%left TPlus TMinus
%left TTimes TSlash

%%

/* Program Structure */

Prog : TProgram TId TSemi FunDecs TEOF { $4 }

FunDecs : FunDecs FunDec { $1 @ [$2] }
        | FunDec         { [$1] }

FunDec : TFunction TId TLParen PDecl TRParen TColon Type Block TSemi { AbSyn.Func ($7, #1 $2, $4, $8, $1) }
       | TProcedure TId TLParen PDecl TRParen Block TSemi            { AbSyn.Proc (#1 $2, $4, $6, $1) }

Block : DBlock SBlock { AbSyn.Block ($1, $2) }

DBlock : TVar Decs { $2 }
       |           { [] }

SBlock : TBegin StmtSeq TSemi TEnd { $2 }

StmtSeq : StmtSeq TSemi Stmt { $1 @ [$3] }
        | Stmt               { [$1] }

/* Variable and Parameter Declarations, Types */

PDecl : Params { $1 }
      |        { [] }

Params : Params TSemi Dec { $1 @ [$3] }
       | Dec              { [$1] }

Dec : TId TColon Type { AbSyn.Dec (#1 $1, $3, #2 $1) }

Decs : Decs Dec TColon { $1 @ [$2] }
     | Dec TColon      { [$1] }

Type : TInt            { (Int, $1) }
     | TChar           { (Char, $1) }
	 | TBool           { (Bool, $1) }
	 | TArray TOf Type { Array ($3, $1)}

/* Statements */

Stmt : TId TLParen CallParams TRParen  { ProcCall (#1 $1, $3, #2 $1) }
     | TIf Exp TThen Block             { IfThEl ($2, $4, ([], []), #2 $1) }
	 | TIf Exp TThen Block TElse Block { IfThEl ($2, $4, $6, #2 $1) }
	 | TWhile Exp TDo Block            { While ($2, $4, $1) }
	 | TReturn Ret                     { Return ($2, $1) }
	 | LVal TAssign Exp                { Assign ($1, $3, $1) }

/* Function and Procedure Parameters and Index Lists */

CallParams : Exps { $1 }
           |      { [] }

Exps : Exp TComma Exps { $1 :: $3 }
     | Exp             { [$1] }

/* L-Values and Expressions */

LVal : TId                          { (Var (#1 $1), #2 $1) }
     | TId TLBracket Exps TRBracket { (Index (#1 $1, $3), #2 $1) }

Ret : Exp { $1 }
    |     { [] }

Exp : TNLit                          { Literal $1 }
    | TBLit                          { Literal $1 }
	| TCLit                          { Literal $1 }
	| TSLit                          { StrLit $1 }
	| TLCurly Exps TRCurly           { ArrLit $1 }
	| LVal                           { LValue $1 }
	| TNot Exp                       { Not ($2, $1) }
	| OP                             { $1 }
	| TLParen Exp TRParen            { $2 }
	| TId TLParen CallParams TRParen { AbSyn.FunApp (#1 $1, $3, #2 $1) }

OP : Exp TPlus Exp  { AbSyn.Plus $1 $3  }
   | Exp TMinus Exp { AbSyn.Minus $1 $3 }
   | Exp TTimes Exp { AbSyn.Times $1 $3 }
   | Exp TSlash Exp { AbSyn.Div $1 $3   }
   | Exp TEq Exp    { AbSyn.Equal $1 $3 }
   | Exp TLess Exp  { AbSyn.Less $1 $3  }
   | Exp TAnd Exp   { AbSyn.And $1 $3   }
   | Exp TOr Exp    { AbSyn.Or $1 $3    }

%%

(* SML trailer, often empty *)
