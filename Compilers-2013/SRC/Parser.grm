%{
(* SML header, after data types *)

  open AbSyn

  fun 
%}

%token <Pos> TProgram TEOF
%token <Pos> TFunction TProcedure TReturn
%token <string, Pos> TId
%token <Pos> TBegin TEnd
%token <Pos> TIf TThen TElse
%token <Pos> TWhile TDo
%token <Pos> TArray
%token <Pos> TOr TAnd TNot
%token <Pos> TVar TOf TChar TBool TInt 
%token <Pos> TSemi TColon TComma TAssign
%token <Pos> TPlus TMinus TTimes TSlash 
%token <Pos> TEq TLess
%token <Pos> TLParen TRParen TLCurly TRCurly TLBracket TRBracket
%token <int, Pos> TNLit
%token <bool, Pos> TBLit
%token <char, Pos> TChar
%token <string, Pos> TSLit

%start Prog

%type <AbSyn.Pos> Pos
%type <AbSyn.Ident> Ident
%type <AbSyn.BasicVal> BasicVal
%type <AbSyn.Value> Value
%type <AbSyn.Type> Type
%type <AbSyn.Exp> Exp
%type <AbSyn.Dec> Dec
%type <AbSyn.LVal> LVal
%type <AbSyn.Stmt> Stmt
%type <AbSyn.StmtBlock> StmtBlock
%type <AbSyn.FunDec> FunDec
%type <AbSyn.Prog> Prog
%%

(* Program Structure *)

Prog : TProgram TId TSemi FunDecs TEOF { $3 }

FunDecs : FunDecs FunDec { $2 : $1 }
        | FunDec         { [ $1 ] }

FunDec : TFunction TId TLParen PDecl TRParen TColon Type Block TSemi { AbSyn.Func ($7, #1 $2, $4, $8, $1) }
       | TProcedure TId TLParen PDecl TRParen Block TSemi            { AbSyn.Proc (#1 $2, $4, $6, $1) }

Block : DBlock SBlock { AbSyn.Block ($1, $2) }

DBlock : TVar Decs { $2 }
       |           { [] }

SBlock : TBegin StmtSeq TSemi TEnd { $2 }
       | Stmt                      { $1 }

StmtSeq : StmtSeq TSemi Stmt { $1 @ [ $3 ] }
        | Stmt               { [ $1 ] }

(* Variable and Parameter Declarations, Types *)

PDecl : Params { $1 }
      |        { [] }

Params : Params TSemi Dec { $3 : $1 }
       | Dec              { $1 }

Dec : TId TColon Type { AbSyn.Dec (#1 $1, $3, #2 $1) }

Decs : Decs Dec TColon { $2 : $1 }
     | Dec TColon      { $1 }

Type : TInt            { (Int, $1) }
     | TChar           { (Char, $1) }
	 | TBool           { (Bool, $1) }
	 | TArray TOf Type { Array ($3, $1)}

(* Statements *)

Stmt : TId TLParen CallParams TRParen  { ProcCall (#1 $1, $3, #2 $1) }
     | TIf Exp TThen Block             { IfThEl ($2, $4, ([], []), #2 $1) }
	 | TIf Exp TThen Block TElse Block { IfThEl ($2, $4, $6, #2 $1) }
	 | TWhile Exp TDo Block            { While ($2, $4, $1) }
	 | TReturn Ret                     { Return ($2, $1) }
	 | LVal TAssign Exp                { Assign ($1, $3, $1) }

(* Function and Procedure Parameters and Index Lists *)

CallParams : Exps { $1 }
           |      { [] }

Exps : Exp TComma Exps { $1 : $3 }
     | Exp             { [ $1 ] }

(* L-Values and Expressions *)

LVal : TId                          { (Var (#1 $1), #2 $1) }
     | TId TLBracket Exps TRBracket { (Index (#1 $1, $3), #2 $1) }

Ret : Exp { $1 }
    |     { [] }

Exp : TNLit                          { Literal $1 }
    | TBLit                          { Literal $1 }
	| TCLit                          { Literal $1 }
	| TSLit                          { StrLit $1 }
	| TLBracket Exps TRBracket       { ArrLit $1 }
	| LVal                           { LValue $1 }
	| TNot Exp                       { Not ($2, $1) }
	| Exp OP Exp                     { (#1 $2) ($1, $3, #2 $2) }
	| TLParen Exp TRParen            { $2 }
	| TId TLParen CallParams TRParen { AbSyn.FunApp (#1 $1, $3, #2 $1) }

OP : TPlus  { (AbSyn.Plus, $1)  }
   | TMinus { (AbSyn.Minus, $1) }
   | TTimes { (AbSyn.Times, $1) }
   | TSlash { (AbSyn.Div, $1)   }
   | TEq    { (AbSyn.Equal, $1) }
   | TLess  { (AbSyn.Less, $1)  }
   | TAnd   { (AbSyn.And, $1)   }
   | TOr    { (AbSyn.Or, $1)    }

%%

(* SML trailer, often empty *)
