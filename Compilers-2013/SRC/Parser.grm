%{
(* SML header, after data types *)

  open AbSyn

  fun 
%}

%token <Pos> TProgram TEOF
%token <Pos> TFunction TProcedure
%token <string, Pos> TId

%start Prog

%%

(* Program Structure *)

Prog : TProgram TId TSemi FunDecs TEOF { $3 }

FunDecs : FunDecs FunDec { $2 : $1 }
        | FunDec         { [ $1 ] }

FunDec : TFunction TId TLParen PDecl TRParen TColon Type Block TSemi { AbSyn.Func ($7, $2, $4, $8, $1) }
       | TProcedure TId TLParen PDecl TRParen Block TSemi            { AbSyn.Proc ($2, $4, $6, $1) }

Block : DBlock SBlock { AbSyn.Block ($1, $2) }

DBlock : TVar Decs { $2 }
       |           { [] }

SBlock : TBegin StmtSeq TSemi TEnd { $2 }
       | Stmt                      { $1 }

StmtSeq : StmtSeq TSemi Stmt 
        | Stmt

(* Variable and Parameter Declarations, Types *)

PDecl : Params { $1 }
      |        { [] }

Params : Params TSemi Dec { $3 : $1 }
       | Dec              { $1 }

Dec : TId TColon Type { AbSyn.Dec (#1 $1, $3, #2 $1) }

Decs : Decs Dec TColon { $2 : $1 }
     | Dec TColon      { $1 }

Type : TInt            { $1 }
     | TChar           { $1 }
	 | TBool           { $1 }
	 | TArray TOf Type { Array ($3, $1)}

(* Statements *)

Stmt : TId TLParen CallParams TRParen  { ProcCall (#1 $1, $3, $1) }
     | TIf Exp TThen Block             { hvor er IfTh typeconstructor? :( }
	 | TIf Exp TThen Block TElse Block { IfThEl ($2, $4, $6, $1) }
	 | TWhile Exp TDo Block            { While ($2, $4, $1) }
	 | TReturn Ret                     { Return ($2, $1) }
	 | LVal TAssign Exp                { Assign ($1, $3, $1) }

(* Function and Procedure Parameters and Index Lists *)

CallParams : Exps { $1 }
           |      { [] }

Exps : Exp TComma Exps { $1 : $3 }
     | Exp             { $1 }

(* L-Values and Expressions *)

LVal : TId                          { (Var (#1 $1), #2 $1) }
     | TId TLBracket Exps TRBracket { (Index (#1 $1, $3), #2 $1) }

Ret : Exp { $1 }
    |     { [] }

Exp : NumLit                         { }
    | LogicLit                       { }
	| CharLit                        { }
	| StringLit                      { }
	| TLBracket Exps TRBracket       { }
	| LVal                           { LValue $1 }
	| TNot Exp                       { Not ($2, $1) }
	| Exp OP Exp                     { (#1 $2) ($1, $3, #2 $2) }
	| TLParen Exp TRParen            { }
	| TId TLParen CallParams TRParen { }

OP : TPlus  { (Plus, $1)  }
   | TMinus { (Minus, $1) }
   | TTimes { (Times, $1) }
   | TSlash { (Div, $1)   }
   | TEq    { (Equal, $1) }
   | TLess  { (Less, $1)  }
   | TAnd   { (And, $1)   }
   | TOr    { (Or, $1)    }

%%

(* SML trailer, often empty *)
